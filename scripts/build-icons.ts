import { type Dirent, promises as fs } from "node:fs"
import path from "node:path"

const cwd = process.cwd()
const inputDir = path.join(cwd, "assets", "icons")
const outputDir = path.join(cwd, "public", "icons")
const typeDir = path.join(cwd, "types")

await ensureDir(outputDir)
await ensureDir(typeDir)

async function main() {
  const files = await listSvgFiles(inputDir)

  if (files.length === 0) {
    console.log(`No SVG files found in ${path.relative(cwd, inputDir)}`)
    return
  }

  const iconNames = files.map(file => iconName(file))
  const spriteFilepath = path.join(outputDir, "sprite.svg")
  const typeOutputFilepath = path.join(typeDir, "icons.d.ts")

  const symbols = await Promise.all(
    files.map(async file => svgToSymbol(path.join(inputDir, file), iconName(file))),
  )

  const spriteContent = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
    "<defs>",
    `${symbols.join("\n")}`,
    "</defs>",
    "</svg>",
    "", // trailing newline
  ].join("\n")

  const spriteChanged = await writeIfChanged(spriteFilepath, spriteContent)

  const typeOutputContent = `// Generated by bun run icons

export type IconName =
${iconNames.map(name => `  | \"${name}\"`).join("\n")};
`

  const typesChanged = await writeIfChanged(typeOutputFilepath, typeOutputContent)

  if (spriteChanged || typesChanged) {
    console.log(`Generated ${files.length} icons -> ${path.relative(cwd, spriteFilepath)}`)
  } else {
    console.log("Icons are up to date")
  }
}

function iconName(file: string) {
  return file.replace(/\.svg$/, "").replace(/\\/g, "/")
}

async function listSvgFiles(dir: string, prefix = ""): Promise<string[]> {
  const entries: Dirent[] = await fs.readdir(dir, { withFileTypes: true }).catch(() => [])

  const files: string[] = []

  for (const entry of entries) {
    const entryPath = path.join(prefix, entry.name)
    const fullPath = path.join(dir, entry.name)

    if (entry.isDirectory()) {
      const nested = await listSvgFiles(fullPath, entryPath)
      files.push(...nested)
    } else if (entry.isFile() && entry.name.toLowerCase().endsWith(".svg")) {
      files.push(entryPath)
    }
  }

  return files.sort((a, b) => a.localeCompare(b))
}

async function svgToSymbol(filepath: string, id: string) {
  const raw = await fs.readFile(filepath, "utf8")
  const cleaned = raw.replace(/<\?xml[^>]*>\s*/g, "").trim()

  const openTagMatch = cleaned.match(/<svg[^>]*>/i)
  const closeIndex = cleaned.lastIndexOf("</svg>")

  if (!openTagMatch || closeIndex === -1) {
    throw new Error(`Invalid SVG: ${path.relative(cwd, filepath)}`)
  }

  const attributes = Array.from(openTagMatch[0].matchAll(/([\w:-]+)="([^"]*)"/g)).filter(
    ([, name]) => !["width", "height", "xmlns", "xmlns:xlink", "version"].includes(name),
  )

  const attributeString = attributes
    .map(([, name, value]) => `${name}="${value}"`)
    .filter(Boolean)
    .join(" ")

  const inner = cleaned.slice(openTagMatch[0].length, closeIndex).trim()

  const attributesWithId = attributeString ? ` ${attributeString}` : ""

  return `<symbol id="${id}"${attributesWithId}>${inner}</symbol>`
}

async function ensureDir(dir: string) {
  await fs.mkdir(dir, { recursive: true })
}

async function writeIfChanged(filepath: string, newContent: string) {
  const currentContent = await fs.readFile(filepath, "utf8").catch(() => "")
  if (currentContent === newContent) return false
  await fs.writeFile(filepath, newContent, "utf8")
  return true
}

await main().catch(err => {
  console.error(err)
  process.exit(1)
})
